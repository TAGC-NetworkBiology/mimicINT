#!/usr/bin/python2.7

import os, sys, string
from optparse import OptionParser
import fileinput
import random

from math import floor

from multiprocessing import Pool


# Created by AZ : 2020/03/23

# To be used in the context of the following projects:
# 
# - RiPCoN
#
# - DIME

#####
##
## Please, list here any update/improvement done on this script by indicating initials 
## and date following this example:
##
## modified by XY : yyyy/mm/dd
## * one-line description of the improvement *
##
## modified by SC: 2020/03/26 - Adapted for Snakefile and configuring hard-coded options
##                              as actual options parsed from command-line arguments.
##
#####


## SEQUENCE RANDOMIZATION
#
# This script generates random disordered regions in a set of sequence of interest
# to assess the statistical significance of the occurrence of short linear motif
# instances based on ELM regular expressions.
#
# It follows the approach proposed by Hagai et al. (PMID: 24882001)
#
# It takes as a input one (or more) FASTA files, where ordered regions are masked, that
# is ordered residues are substituted by 'X'. In principle, Order/disorder predictions can 
# be generated by any tools. However, here, the script is written to work with predictions
# at different disorder propensity score threshold that must be provided as input
# parameter. Moreover,
#
# The FASTA file should be follow SLiMProb naming convention for masked sequence fasta
# files. Each FASTA file should contain the sequences of a given strain (bacterium or virus)
#
# Disorder regions are used to create two reference backgrounds of disordered amino acids:
#
# Intra-strain
# Inter-strain
#
# the script shuffles the background and samples a set of shuffled amino acids of the 
# same size of the predicted disordered amino acids in the "true" sequences.
#
# The random sampling is performed n times, as defined by the iteration parameter
##

## DISORDER CONTENT
#
# An additional feature is that the script also generates the disorder content of each
# sequence in the FASTA file(s). The disorder content is calculated as the fraction of
# predicted disordered amino acid divided by the length of the protein.
##

####################

## CONSTANTS

## Background flags used to create the folder
BACKGROUND_FLAG_INTRA = "background_intra"
BACKGROUND_FLAG_INTER = "background_inter"

BACKGROUND_CODE_INTRA_ONLY = "1"
BACKGROUND_CODE_INTER_ONLY = "2"
BACKGROUND_CODE_INTRA_AND_INTER = "3"
DEFAULT_BACKGROUND_CODE = BACKGROUND_CODE_INTRA_AND_INTER

# Default number of shuffling to perform
DEFAULT_ITERATIONS = 1000

# Default maximum number of files generated by a single process
DEFAULT_MAX_FILES_PER_PROCESS = 1000

## List of options allowed
# Path to masked fasta files folder
MASKED_FASTA_INPUT_FOLDER_OPTION = "MASKED_FASTA_INPUT_FOLDER"
# Path to disorder content folder
DISORDER_CONTENT_FOLDER_OPTION = "DISORDER_CONTENT_FOLDER"
# Path to randomized sequences folder
RANDOMIZED_SEQUENCE_FOLDER_OPTION = "RANDOMIZED_SEQUENCE_FOLDER"
# Path to the placeholder (see end of the file for more information)
SNAKEFILE_PLACEHOLDER_PATH_OPTION = 'SNAKEFILE_PLACEHOLDER_PATH'
# Strain names
STRAIN_NAMES_OPTION = "STRAIN_NAMES"
# Number of iterations
ITERATIONS_OPT = "ITERATIONS_OPT"
# Background(s) to use
BACKGROUND_CODE_OPTION = "BACKGROUND_CODE"
# Maximum number of files generated by one process
MAXIMUM_FILES_GENERATED_OPTION = "MAXIMUM_FILES_GENERATED"
# Number of threads available
THREAD_NB_COUNT_OPTION = "THREAD_NB_COUNT"

OPTION_LIST = [ [ "-i", "--input", "store", "string", MASKED_FASTA_INPUT_FOLDER_OPTION, None, "The path of the folder containing fasta masked files." ],
                [ "-d", "--disorder", "store", "string", DISORDER_CONTENT_FOLDER_OPTION, None, "The path of the folder where the disorder files have to be written." ],
                [ "-r", "--randomSeq", "store", "string", RANDOMIZED_SEQUENCE_FOLDER_OPTION, None, "The path of the folder where the randomized fasta files have to be written." ],
                [ "-p", "--placeholder", "store", "string", SNAKEFILE_PLACEHOLDER_PATH_OPTION, None, "The path of a placeholder to create at the end of the execution of the script. \
                                                                                                      Leave empty if you do not intend to generate such placeholder file." ],
                [ "-s", "--strain", "store", "string", STRAIN_NAMES_OPTION, None, "The comma-separated list of strains." ],
                [ "-n", "--shufflingNumber", "store", "string", ITERATIONS_OPT, None, "The number of fasta files with random sequences to generate." ],
                [ "-b", "--backgroundCode", "store", "string", BACKGROUND_CODE_OPTION, None, ( "The type of background to use (" + BACKGROUND_CODE_INTRA_ONLY + ": intra background only, " + 
                                                                                                                                   BACKGROUND_CODE_INTER_ONLY + ": inter background only)." +
                                                                                                                                   BACKGROUND_CODE_INTRA_AND_INTER + ": both intra and inter backgrounds)." ) ],
                [ '-t', '--threads', 'store', 'string', THREAD_NB_COUNT_OPTION, None, 'The number of threads allocated to the SLiMProb processes.' ],
                [ "-m", "--maxFiles", "store", "string", MAXIMUM_FILES_GENERATED_OPTION, None, "The maximum number of files generated by a single process." ] ]



####################


def randomize(arg_list):
    
    ( iterations,
      randomized_sequences_folder,
      strain,
      sequence_disorder_dict,
      sequence_dict,
      disorder_background,
      background_flag,
      multiplier ) = arg_list

    ## this function takes as input the sequence positions dictionaries, the reference
    ## background of disordered residues and the number of iterations.
    
    print strain,background_flag
    
    for n in range(iterations):
    
        if not os.path.isdir(os.path.join( randomized_sequences_folder, background_flag, strain)):
            os.makedirs(os.path.join( randomized_sequences_folder, background_flag, strain))
        output = open( os.path.join( randomized_sequences_folder, 
                                     background_flag, 
                                     strain, 
                                     strain + '_random_' + str( iterations * multiplier + n) + '.fasta'
                                     ), 'w')
        
        #print sequence_disorder_dict
        
        ## reference background is shuffled again.        
        random.shuffle(disorder_background)

        #print disorder_background
        #print len(disorder_background)
        
        for seq in sequence_disorder_dict:
        
            #print '-',seq,sequence_disorder_dict[seq],len(sequence_disorder_dict[seq])
            
            ## sampling disordered residues from the background
            rnd_sample = random.sample(disorder_background,len(sequence_disorder_dict[seq]))

            #print rnd_sample, len(rnd_sample)    
    
            shuffled_sequence = []

            shuffle_disorder_dict = {}

            ## disordered residues in the "true" sequence are substituted by the sampled
            ## residues in the reference background. Substitution follows sequence order
            
            for x in xrange(len(sequence_disorder_dict[seq])):

                #print sequence_disorder_dict[seq][x]
                #print (sequence_disorder_dict[seq][x][0],rnd_sample[x])
                shuffled_sequence.append((sequence_disorder_dict[seq][x][0],rnd_sample[x]))
                shuffle_disorder_dict[sequence_disorder_dict[seq][x][0]] = rnd_sample[x]
    
            #print '\n'
            #print sequence_disorder_dict[seq]
            #print shuffled_sequence
            #print sequence_dict[seq]

            ## The randomize sequence position dictionary is converted in a string
            random_sequence = ''
            for z in xrange(len(sequence_dict[seq])):
                    if sequence_dict[seq][z][0] in shuffle_disorder_dict:
        
                        #print sequence_dict[seq][z], shuffle_disorder_dict[sequence_dict[seq][z][0]]
                        random_sequence += shuffle_disorder_dict[sequence_dict[seq][z][0]]
                    else:
                        #print sequence_dict[seq][z]
                        random_sequence += sequence_dict[seq][z][1]
            
            #print seq
            #print random_sequence
            #print len(random_sequence)
            
            ## the random sequence is written in the FASTA file of the corresponding
            ## strain and iteration
            output.write('>'+seq+'\n'+random_sequence+'\n')
        
        output.close()
        


def main( masked_fasta_input_folder, disorder_content_folder, randomized_sequences_folder, \
          strains, iterations, background_code, thread_nb, max_files_per_process):
        
    # Dictionaries to store strain-level data
    strain_fragment_dict = {}
    strain_position_dict = {}
    ## initialising the reference background inter-strains
    background_disorder_inter = []
    
    # dictionary with intra-strain background
    background_disorder_intra_dict = {}
    
    ## iterating on the different strains
    for strain in strains:

        ## initialising the reference background intra-strain
        background_disorder_intra = []
        
        disorder_fraction_dict = {}
        
        sequence_len_dict = {}
        sequence_fragment_dict = {}
        sequence_position_dict = {}
        masked_sequences = open( os.path.join( masked_fasta_input_folder, strain+'.FreqDis.masked.fas'), 'r')

        ## Output file for storing disorder fractions.
        disorder_file = open( os.path.join( disorder_content_folder, strain+'_iupred.txt'), 'w')
        disorder_file.write('Strain\tUniProt_ID\tUniProt_AC\tdisorder_fraction\n')
        
        ## processing the "true" sequence FASTA file
                    
        fasta_obj = masked_sequences.read()

        fasta_blocks = fasta_obj.split('\n>')

        for seq in fasta_blocks:

            seq_lines = seq.split('\n')

            protein_identifier = seq_lines[0].replace('>','')

            #print protein_identifier
            
            uniprot_ac = protein_identifier.split('__')[1]
            uniprot_id = protein_identifier.split('__')[0]
            
            sequence = ''

            for x in xrange(len(seq_lines)):
                if x != 0:
    
                    sequence += seq_lines[x]
            
    
            #print len(sequence)
            #print sequence
            #print '-'
            
            sequence_len_dict[protein_identifier] = len(sequence)
            
            ## calculate disorder content and store it in a dictionary 
        
            order_aa = sequence.count('X')
            disorder_aa = len(sequence) - order_aa
            
            #print order_aa
            #print disorder_aa                
            if disorder_aa == 0:
                disorder_fraction = 0.0
            else:
                disorder_fraction = round(float(disorder_aa)/float(len(sequence)),3)
            
            disorder_fraction_dict[uniprot_id+'\t'+uniprot_ac] = disorder_fraction
            
            ###
            
            
            ## identifying disordered amino acids and defining disorder backgrounds
            
            sequence_positions = []
            
            i = 0 
            
            disorder_positions = []
            
            while i < len(sequence):

#                    print sequence[i]

                sequence_positions.append((i,sequence[i]))

                if sequence[i] != 'X':
    
#                        print i, sequence[i]
    
                    disorder_positions.append((i,sequence[i]))
                    background_disorder_intra.append(sequence[i])
                    background_disorder_inter.append(sequence[i])
                
                else:
                    
                    pass
#                        print i, sequence[i]
        
                i = i + 1
                
#                print disorder_positions            
            sequence_fragment_dict[protein_identifier] = disorder_positions
            sequence_position_dict[protein_identifier] = sequence_positions
        
        print 'background disorder intra size:'
        print len(background_disorder_intra), strain
        #loading strain data into dictionaries used for randomisation
        background_disorder_intra_dict[strain] = background_disorder_intra
        strain_fragment_dict[strain] = sequence_fragment_dict
        strain_position_dict[strain] = sequence_position_dict
        
        ## writing disorder content to file
        for disorder_fraction_id in disorder_fraction_dict:
        
            disorder_fraction = disorder_fraction_dict[disorder_fraction_id]
        
            disorder_file.write(strain+'\t'+disorder_fraction_id+'\t'+str(disorder_fraction)+'\n')
            
        disorder_file.close()

        #print sequence_fragment_dict
        #print disorder_fraction_dict
        #print len(disorder_fraction_dict)
    
    print '###'
        
    #print background_disorder_intra
    #print len(background_disorder_intra)

    print 'background disorder inter size:'
    print len(background_disorder_inter), 
    print 'END'
    
    
    # Perform the randomization
    # -------------------------
        
    dividend = int( floor( iterations / max_files_per_process ) )
    remainder = iterations % max_files_per_process
    
    iteration_multiplier_couples = []
    
    if ( iterations < max_files_per_process ):
        iteration_multiplier_couples.append( ( iterations, 0 ) )
    else:
        for k in range( dividend ):
            iteration_multiplier_couples.append( ( max_files_per_process, k ) )
        if ( remainder != 0 ):
            iteration_multiplier_couples.append( ( remainder, dividend + 1 ) )
    
    
    # Instantiate the list of arguments
    randomize_args = []
    
    for ( iterations_nb, multiplier ) in iteration_multiplier_couples:
        
        for s in strain_position_dict:
        
            ## The randomisation function is called twice per background model. 
            ## Nothing is returned to main()
            ##
            ## TODO: this could be optimised, although not necessary for DIME (only one 
            ## threshold is used.
            
            ## background intra-strain (pick the specific background for each strain)
            if ( background_code in [BACKGROUND_CODE_INTRA_ONLY, BACKGROUND_CODE_INTRA_AND_INTER]):
                randomize_args.append( ( iterations_nb,
                                         randomized_sequences_folder,
                                         s,
                                         strain_fragment_dict[s],
                                         strain_position_dict[s],
                                         background_disorder_intra_dict[s],
                                         BACKGROUND_FLAG_INTRA,
                                         multiplier
                                        ) )
        
            ## background inter_strain
            if ( background_code in [BACKGROUND_CODE_INTER_ONLY, BACKGROUND_CODE_INTRA_AND_INTER]):
                randomize_args.append( ( iterations_nb,
                                         randomized_sequences_folder,
                                         s,
                                         strain_fragment_dict[s],
                                         strain_position_dict[s],
                                         background_disorder_inter,
                                         BACKGROUND_FLAG_INTER,
                                         multiplier
                                        ) )
        
    # Instantiate the pool
    p = Pool( thread_nb )
    p.map( randomize, randomize_args )
    p.close()
    
    # Wait for all processes to be completed
    p.join()
            


####################    
if __name__ == '__main__':
    
    ## Command-line arguments are parsed.
    # Store the various option values into a dictionary
    optionParser = OptionParser()    
    for current_opt in OPTION_LIST:
        optionParser.add_option( current_opt[0],
                                 current_opt[1],
                                 action = current_opt[2],
                                 type = current_opt[3],
                                 dest = current_opt[4],
                                 default = current_opt[5],
                                 help = current_opt[6] )
    (opts, args) = optionParser.parse_args()
    option_dict = vars(opts)
    
    # Get the path of the input directory
    masked_fasta_input_folder = option_dict[MASKED_FASTA_INPUT_FOLDER_OPTION]
    
    # Get the path of the output directories 
    # - Directory in which files that report the disorder content 
    #   for each protein of each strain have to be written.
    disorder_content_folder = option_dict[DISORDER_CONTENT_FOLDER_OPTION]
    if not os.path.isdir(disorder_content_folder):
        os.makedirs(disorder_content_folder)
    
    # - Directory in which fasta files containing randomized sequences
    #   for each protein of each strain have to be written.
    randomized_sequences_folder = option_dict[RANDOMIZED_SEQUENCE_FOLDER_OPTION]
    if not os.path.isdir(randomized_sequences_folder):
        os.makedirs(randomized_sequences_folder)
     
     
    # Get the strain names
    strains = option_dict[STRAIN_NAMES_OPTION]
    if strains:
        strains = strains.split(',')
    else:
        exit( "The list of strains to use has to be provided.")
     
    # Get the number of iterations to perform
    iterations = option_dict[ITERATIONS_OPT]
    if iterations:
        iterations = int( iterations)
        if iterations<1:
            raise Exception( "The number of iterations ("+ str( iterations ) + " to perform has to be a positive integer.")
    else:
        iterations = DEFAULT_ITERATIONS
     
    # Get the type of background to use to generate the sequences
    background_code = option_dict[BACKGROUND_CODE_OPTION]
    if ( background_code not in [BACKGROUND_CODE_INTRA_ONLY, 
                                 BACKGROUND_CODE_INTER_ONLY, 
                                 BACKGROUND_CODE_INTRA_AND_INTER] ):
        raise Exception( "The background code selected ("+ background_code + ") is not allowed.")
    
    if ( not background_code ):
        background_code = DEFAULT_BACKGROUND_CODE

    # Get the number of threads
    thread_nb = option_dict.get( THREAD_NB_COUNT_OPTION )
    if thread_nb:
        try:
            thread_nb = int( thread_nb )
        except:
            raise Exception( 'The number of threads has to be an integer.' )
        else:
            if ( thread_nb <= 0 ):
                raise Exception( 'The number of threads has to be a positive integer.' )
    else:
        thread_nb = 1
        
    # Get the maximum number of file to generate per process 
    max_files_per_process = option_dict[MAXIMUM_FILES_GENERATED_OPTION]
    if max_files_per_process:
        try:
            max_files_per_process = int(max_files_per_process)
        except:
            raise Exception( "The maximum number of files generated by process must be an integer.")
        else:
            if ( max_files_per_process < 0 ):
                raise Exception( "The maximum number of files generated by process must be a positive integer.")
    else:
        max_files_per_process = DEFAULT_MAX_FILES_PER_PROCESS
    
    ## main function is called.
    main( masked_fasta_input_folder, disorder_content_folder, randomized_sequences_folder, \
          strains, iterations, background_code, thread_nb, max_files_per_process)
    
    ## Create a placeholder empty file
    ## NB: This placeholder may be necessary to use the current script 
    ##     with Snakemake if you want to avoid the use of checkpoints. 
    ##     This placeholder is not necessary for any other use.
    placeholder_file_path = option_dict[SNAKEFILE_PLACEHOLDER_PATH_OPTION]
    if placeholder_file_path:
        # Create parent directories if necessary
        basedir = os.path.dirname(placeholder_file_path)
        if not os.path.isdir(basedir):
            os.makedirs(basedir)
        # Create the file
        with open(placeholder_file_path, 'w') as placeholder:
            placeholder.write('This is a placeholder for Snakemake.\n')
    